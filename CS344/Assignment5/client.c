/**
 * @file client.c
 * @author Kevin Sekuj (sekujk@oregonstate.edu)
 *
 * @brief  Client which makes a socket conncetion to an encrytpion/decryption server
 *         on a specified port. The client accepts a plaintext file, a key, and a port
 *         as arguments. The key is generated by keygen.c, which is used to encrypt
 *         the plaintext file using modulus addition, and sends bytes from the plaintext
 *         and key files to the server in groups of two. It receives encrypted bytes
 *         back and writes them to stdout. If it is a decryption client, it sends
 *         encrypted text and a key to the decryption server and writes decrypted
 *         bytes to stdout.
 *
 *         This file compiles into both an encryption and decryption client using
 *         preprocessor macros. The clients are essentially identical, except
 *         that they send different handshake values to the server (0 or 1) to
 *         identity as either an encryption or decryption client.
 *
 *
 *        REFERENCE: This client program heavily adapts code from Beej's
 *        Guide to Network Programming, section 6. This guide was referenced
 *        in the OTP assignment prompt and I decided to use the networking
 *        boilerplate code from here instead of the sample program.
 *
 *        https://beej.us/guide/bgnet/html/#client-server-background
 *
 * @version 0.1
 * @date 2022-06-05
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>

/**
 * @brief Boilerplate from beej's to setup the address struct for the
 *        server socket for IPv4 or IPv6
 *
 * @param sa struct describing a generic sock address
 * @return void* address of ipv4/ipv6 address attribute
 */
void *get_in_addr(struct sockaddr *sa)
{
  if (sa->sa_family == AF_INET)
  {
    return &(((struct sockaddr_in *)sa)->sin_addr);
  }

  return &(((struct sockaddr_in6 *)sa)->sin6_addr);
}

int main(int argc, char *argv[])
{

  // initialize file pointers to open plaintext and key files
  FILE *fpText;
  FILE *fpKey;

  // handle invalid args and print usage
  if (argc != 4)
  {
    fprintf(stderr, "usage: plaintext key port\n");
    exit(1);
  }

  // open args 1 and 2, plaintext and key for reading
  fpText = fopen(argv[1], "rb");
  fpKey = fopen(argv[2], "rb");

  if (fpText == NULL || fpKey == NULL)
  {
    fprintf(stderr, "Error: Could not open file\n");
    exit(1);
  }

  // check for invalid keygen length
  fseek(fpKey, 0L, SEEK_END);
  int keygenLength = ftell(fpKey);
  fseek(fpKey, 0L, SEEK_SET);

  // check for invalid keygen length
  fseek(fpText, 0L, SEEK_END);
  int plaintextLength = ftell(fpText);
  fseek(fpText, 0L, SEEK_SET);

  if (keygenLength < plaintextLength)
  {
    fprintf(stderr, "Error: Encryption key is too short\n");
    exit(1);
  }

  // Boilerplate from Beej's for listening initializing socket connection
  // and listening for new connection on it
  int sockfd, numbytes;
  struct addrinfo hints, *servinfo, *p;
  int rv;
  char s[INET6_ADDRSTRLEN];

  // Boilerplate from Beej's for setting up desired address family values
  // such as specifying preferred socket type
  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  if ((rv = getaddrinfo("localhost", argv[3], &hints, &servinfo)) != 0)
  {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    return 1;
  }

  // Boilerplate from Beej's networking guide - Attempt to connect to provided socket
  for (p = servinfo; p != NULL; p = p->ai_next)
  {
    if ((sockfd = socket(p->ai_family, p->ai_socktype,
                         p->ai_protocol)) == -1)
    {
      continue;
    }

    if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1)
    {
      close(sockfd);
      continue;
    }

    break;
  }

  if (p == NULL)
  {
    fprintf(stderr, "client: failed to connect\n");
    return 2;
  }

  inet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr),
            s, sizeof s);

  // Free servinfo when done with it
  freeaddrinfo(servinfo);

  /** Beej's networking guide boilerplate end */

  // We use preprocessor macros instead of copy pasting encode/decode
  // servers/clients. We define a system where the value "0" indicates
  // an encoding client, and the value "1" indicates the decoding client

  // When the client file is compiled, it will be compiled into an executable
  // with the ENCODE flag and without it in order to create these two files
#ifdef ENCODE
  char handshake = 0;
#else
  char handshake = 1;
#endif

  // Attempt to secure the hadnshake from the server. If the handshake fails,
  // or the client type does not match the server type, reject it.
  if (send(sockfd, &handshake, 1, 0) != 1)
  {
    perror("Handshake failed");
    exit(2);
  }

  // Initialize two chars to hold two bytes read from the plaintext and key files,
  // respectively
  char plainTextByte, keyByte, charRead;

  // Keep track of bytes read and bytes sent - we cannot guarantee that all bytes
  // sent to the server will be read back when we're finished reading from plaintext
  int bytesRead = 0;
  int bytesSent = 0;

  // while we can still read bytes from plaintext..
  while ((plainTextByte = fgetc(fpText)) != EOF)
  {

    // ignore newline characters
    if (plainTextByte == '\n')
    {
      continue;
    }

    // terminate on invalid characters
    if (plainTextByte < 'A' || plainTextByte > 'Z')
    {
      if (plainTextByte != ' ')
      {

        fprintf(stderr, "Error: Detected an invalid character %c.\n", plainTextByte);
        exit(1);
      }
    }

    // check if we've read EOF from a key before EOF from plaintext
    if ((keyByte = fgetc(fpKey)) == EOF)
    {
      fprintf(stderr, "Encryption key is too short\n.");
      exit(1);
    }

    // read two bytes from message and key and send them to server
    int sendResult;
    do
    {
      sendResult = send(sockfd, &plainTextByte, 1, 0);

      if (sendResult == -1)
      {
        perror("send");
        exit(1);
      }
    } while (sendResult != 1);

    // same as above, but from key file, read a single byte and send it
    do
    {
      sendResult = send(sockfd, &keyByte, 1, 0);

      if (sendResult == -1)
      {
        perror("send");
        exit(1);
      }
    } while (sendResult != 1);

    // increment bytes sent after sending our pair of bytes to the server
    bytesSent++;

    // try and receive an arbitrary number of bytes from our enc/dec server
    while ((numbytes = recv(sockfd, &charRead, 1, MSG_DONTWAIT)) == 1)
    {
      fputc(charRead, stdout);
      bytesRead++;
    }

    // exit if our recv function actually fails
    if (numbytes == -1)
    {
      if (errno == EAGAIN || errno == EWOULDBLOCK)
      {
        // EAGAIN and EWOULDBLOCK can be raised when we're performing nonblocking IO
        // indicating no data is available at the moment - but we don't want to exit here
        // reference: https://stackoverflow.com/questions/4058368/what-does-eagain-mean
      }
      else
      {
        exit(1);
      }
    }
  }

  // receive any remaining bytes and print them
  while (bytesRead < bytesSent)
  {
    if ((numbytes = recv(sockfd, &charRead, 1, 0)) == -1)
    {
      exit(1);
    }

    if (numbytes == 0)
    {
      continue;
    }

    fputc(charRead, stdout);
    bytesRead++;
  }

  // end with a newline, pass a STOP signal along to the server to terminate the
  // socket stream
  printf("\n");
  char STOP = EOF;
  send(sockfd, &STOP, 1, 0);

  // finished exhanging data with the server, close socket connection and exit
  close(sockfd);
  return 0;
}